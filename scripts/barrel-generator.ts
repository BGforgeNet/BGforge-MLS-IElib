/**
 * Barrel file generator for bg2/index.ts.
 *
 * Scans all TypeScript source files in a directory, extracts their exported
 * names, and generates a barrel re-export file grouped by section.
 */

import * as fs from "fs";
import * as path from "path";
import { log } from "./utils.js";

// Types

export interface ModuleExports {
  types: string[];
  values: string[];
}

/**
 * Barrel section indices. Modules are grouped into sections, then sorted
 * alphabetically within each section.
 */
export const enum Section {
  Actions = 0,
  IDS = 1,
  Triggers = 2,
  Help = 3,
}

// Constants

const SECTION_COMMENTS: Readonly<Record<Section, string>> = {
  [Section.Actions]: "// --- Actions (generated from IESDP) ---",
  [Section.IDS]: "// --- IDS types and constants ---",
  [Section.Triggers]: "// --- Triggers (generated from IESDP) ---",
  [Section.Help]: "// Help() is both an action and a trigger -- lives in a separate file.",
};

const OBJECT_MODULES = new Set(["./object.d", "./object"]);

const BARREL_HEADER = [
  "/**",
  " * BG2 barrel re-exports.",
  " *",
  " * Generated by ts-update. Do not edit manually.",
  " *",
  " * Uses named re-exports (not export *) so esbuild can statically resolve each",
  " * binding without falling back to runtime __reExport helpers for externalized",
  " * .d.ts modules.",
  " */",
  "",
];

// Functions

/**
 * Extracts exported type and value names from a TypeScript source file.
 * Deduplicates function overloads (same name exported multiple times).
 */
export function extractExportedNames(fileContent: string): ModuleExports {
  const types = new Set<string>();
  const values = new Set<string>();

  for (const line of fileContent.split("\n")) {
    let match;
    if ((match = line.match(/^export declare type (\w+)/))) {
      const name = match[1];
      if (name) types.add(name);
    } else if ((match = line.match(/^export declare (?:const|function|enum) (\w+)/))) {
      const name = match[1];
      if (name) values.add(name);
    } else if ((match = line.match(/^export (?:enum|const) (\w+)/))) {
      const name = match[1];
      if (name) values.add(name);
    }
  }

  return { types: [...types], values: [...values] };
}

/**
 * Computes the import path for a source file relative to the barrel.
 * Strips the `.ts` suffix; keeps `.d` and `.ids.d` infixes intact.
 * - `foo.ids.d.ts` -> `./foo.ids.d`
 * - `foo.d.ts` -> `./foo.d`
 * - `foo.ts` -> `./foo`
 */
export function toModulePath(filename: string): string {
  return `./${filename.replace(/\.ts$/, "")}`;
}

/**
 * Returns the barrel section for a given module path.
 */
export function moduleSection(modulePath: string): Section {
  if (modulePath === "./actions.d") return Section.Actions;
  if (modulePath === "./triggers.d") return Section.Triggers;
  if (modulePath === "./help.d") return Section.Help;
  return Section.IDS;
}

/**
 * Formats an export statement with one symbol per line.
 */
export function formatExportLine(keyword: "export" | "export type", names: readonly string[], modulePath: string): string {
  if (names.length === 1) {
    return `${keyword} { ${names[0]} } from '${modulePath}';`;
  }

  const lines = [
    `${keyword} {`,
    ...names.map((name) => `  ${name},`),
    `} from '${modulePath}';`,
  ];
  return lines.join("\n");
}

/**
 * Builds sorted module map from source files in a directory.
 * Reads each .ts file (excluding index.ts), extracts exports, sorts names.
 */
function buildModuleMap(bg2Dir: string): Map<string, ModuleExports> {
  const allFiles = fs.readdirSync(bg2Dir)
    .filter((f) => f !== "index.ts" && f.endsWith(".ts"));

  const moduleMap = new Map<string, ModuleExports>();
  for (const file of allFiles) {
    const content = fs.readFileSync(path.join(bg2Dir, file), "utf-8");
    const exports = extractExportedNames(content);
    if (exports.types.length === 0 && exports.values.length === 0) {
      continue;
    }
    const sorted: ModuleExports = {
      types: [...exports.types].sort(),
      values: [...exports.values].sort(),
    };
    moduleMap.set(toModulePath(file), sorted);
  }

  return moduleMap;
}

/**
 * Assembles barrel file output lines from a sorted module map.
 * Groups modules by section with decorative comments.
 */
function buildBarrelOutput(moduleMap: Map<string, ModuleExports>): string[] {
  const sortedModules = [...moduleMap.keys()].sort((a, b) => {
    const sd = moduleSection(a) - moduleSection(b);
    return sd !== 0 ? sd : a.localeCompare(b);
  });

  const out: string[] = [...BARREL_HEADER];
  let currentSection: Section | -1 = -1;
  let inObjectGroup = false;

  for (const modulePath of sortedModules) {
    const section = moduleSection(modulePath);
    const exports = moduleMap.get(modulePath);
    if (!exports) continue;
    const isObject = OBJECT_MODULES.has(modulePath);

    // Section transition
    if (section !== currentSection) {
      if (currentSection !== -1) out.push("");
      out.push(SECTION_COMMENTS[section]);
      currentSection = section;
      inObjectGroup = false;
    }

    // Sub-section comments within IDS
    if (section === Section.IDS) {
      if (isObject && !inObjectGroup) {
        out.push("");
        out.push("// --- Object identifiers ---");
        inObjectGroup = true;
      } else if (!isObject && inObjectGroup) {
        out.push("");
        out.push("// --- More IDS types and constants ---");
        inObjectGroup = false;
      }
    }

    if (exports.types.length > 0) {
      out.push(formatExportLine("export type", exports.types, modulePath));
    }
    if (exports.values.length > 0) {
      out.push(formatExportLine("export", exports.values, modulePath));
    }
  }

  out.push("");
  return out;
}

/**
 * Generates the bg2/index.ts barrel file by scanning all sibling modules
 * and extracting their exported names.
 */
export function generateBarrelFile(bg2Dir: string): void {
  const moduleMap = buildModuleMap(bg2Dir);
  const output = buildBarrelOutput(moduleMap);

  const outputPath = path.join(bg2Dir, "index.ts");
  fs.writeFileSync(outputPath, output.join("\n"), "utf-8");
  log(`Barrel file written to ${outputPath} (${moduleMap.size} modules)`);
}
